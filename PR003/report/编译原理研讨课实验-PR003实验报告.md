[TOC]

# 编译原理研讨课实验PR003实验报告

## 任务说明
    基于PRJ1函数标注以及PRJ2AST生成的实现上，进一步产生llvm中间代码（IR）。并能得到正确运行的二进制文件。
## 成员组成
陈灿宇
宋鹏皓
金越
## 实验设计

### 设计思路
>PR3代码生成主要做的就是将`#pragma elementWise`标注函数里形如`C=A+B`、`C=A*B`、`C=A`的表达式进行语义翻译，即产生等价的`for`循环。
>
>1.设计参考：`CodeGenFunction::EmitForStmt(const ForStmt &S)`函数
>该函数用来产生`for`语句的中间代码，从该函数我们知道了`for`语句在被翻译为IR时，被分为四个基本块（所谓基本快就是除了最后一条语句之外，中间不会有跳转语句）：
>>(1)`for.body` 循环的主体部分，即`for`语句用`{}`括起来的部分。对于elementWise翻译来说，就是`C[i] = A[i] + B[i]`（以加法为例）。该基本快最后无条件跳转到`for.inc`基本快。
>>(2)`for.cond` 循环继续的判断部分，比较累加量和边界值的大小，判断循环是否继续，在elemtnWise翻译中是遍历数组用的index `i` 和 数组大小 。`data_num`的比较。 该基本快最终需要做条件跳转，在满足循环条件时跳转到基本快`for.inc`。在不满足时跳转到基本快`for.end`结束循环。
>>(3)`for.inc` 循环累加部分，即通常的`i++`部分.在elemtnWise翻译中是将遍历数组用的index加1. 该基本快结束时无条件跳转到`for.cond`基本快。
>>(4)`for.end` 循环结束部分。
>>(5)优化：实际上，每次`for.body`调用后都要进入到`for.inc`，我们可以将这两个基本快合并为一个基本快（删去`for.body`最后的无条件跳转语句）
>
>2.关键API：
>>在中间代码API`IRBuilder.h`文件中定义了很多用于产生特定IR指令的函数，例如用于数据搬运的`load`和`store`指令，以及无条件跳转指令`BR`和条件跳转指令`CondBR`。更有用于数据运算的`Add`和`Mul`指令。调用这些函数，实际上我们就是根据表达式写IR汇编。
>
>3.语法树适配
>>我们生成的AST和老师的大致上相同，但在处理`C=A`这种赋值语句时，我们并没有将等号右边的表达式转换为`ImplicitExpr`，因此如果按老师给的判断条件的话，就不会进入`if(ImplicitCastExpr::classof(rhs))`正确时执行的操作。因此这里进行了AST的适配。
>
>4.类型问题
>>由于Clang中的AST和LLVM的IR有着很大的类型区别，所以我们在生成IR指令时，要特别注意Clang中的类型到LLVM中类型的转换。

### 实验实现

### 其它

## 总结

### 实验结果总结

### 分成员总结
>组员：金越
这次实验完成了`#pragma elementWise`编译制导的最后一部分：代码生成。实际上就是对我们数组运算表达式进行语义翻译，翻译为等价的`for`循环的过程。参考`llvm`中原有的`for`语句翻译是很有帮助的，这使得我们知道了将`for`循环划分为基本快，其间采用跳转语句实现连接的逻辑。根据这个我们又找到了产生IR指令的API，那么实际上整个实验的实现就很清除明了了，剩下的只是实现细节的问题，比如类型转换，AST适配等。在Debug的过程中我们遇到了很多不可思议的错误，比如一个加了`#pragma elementWise`标注的`main()`函数在调用printf等库函数时会报错：发生`"type mismatch in call argument!"`的`fail`。这一开始让我们束手无策，但通过dump`main`函数的AST我们发现有和没有`#pragma elementWise`标注的两种情况下，printf参数的类型有很大的不同，于是我们猜想可能是我们PRJ2更改的函数在别的地方调用时错误的转换了类型，而在这些修改了的函数中`CheckSingleAssignmentConstraints()`在非我们调用的其他地方调用了很多次，于是我们重写了一个`CheckSingleAssignmentConstraints()`单独用于我们AST中的调用，剩余的调用用的是原来函数。果然，这样做就将这个问题完美的解决了。Debug的过程很辛苦，但由此也积累了很多经验，也算是值得的付出。至此我们完成了`#pragma elementWise`的实验，最终使得编译器支持数组整体的加法、乘法和赋值运算。



